# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
    subscription: Subscription
}

directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

directive @goModel(model: String, models: [String!]) on SCALAR | OBJECT | INTERFACE | UNION | ENUM | INPUT_OBJECT

directive @goTag(key: String!, value: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

directive @hasRole(role: StaffRole!) on FIELD_DEFINITION

directive @id on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @isAuthenticated on FIELD_DEFINITION

directive @validate(constraint: String!) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

interface Gorm {
    createdAt: Time!
    deletedAt: Time
    id: ID!
    updatedAt: Time!
}

type Admin implements Gorm {
    createdAt: Time!
    deletedAt: Time
    email: String!
    id: ID!
    name: String!
    password: String
    updatedAt: Time!
}

type AuthParams {
    role: StaffRole!
    storeId: Int!
    userId: Int!
}

type AuthPayload {
    accessToken: String!
    store: Store
    user: User!
}

type Brand implements Gorm {
    createdAt: Time!
    deletedAt: Time
    id: ID!
    manufacturer: String
    name: String!
    product: Product!
    productId: Int!
    updatedAt: Time!
}

type Category implements Gorm {
    createdAt: Time!
    deletedAt: Time
    id: ID!
    name: String!
    store: Store
    storeId: Int
    updatedAt: Time!
}

type Customer implements Gorm {
    address: String
    comment: String
    createdAt: Time!
    deletedAt: Time
    dob: Time
    email: String
    gender: GenderType
    id: ID!
    name: String!
    phone: String
    store: Store!
    storeId: Int!
    tin: String
    type: CustomerType!
    updatedAt: Time!
    user: User
    userId: Int
}

type Expense implements Gorm {
    createdAt: Time!
    deletedAt: Time
    id: ID!
    name: String!
    store: Store!
    storeId: Int!
    type: ExpenseType!
    updatedAt: Time!
}

type Item implements Gorm {
    batch: String
    brand: Brand
    brandId: Int
    buyingPrice: String!
    createdAt: Time!
    deletedAt: Time
    description: String
    expiresAt: Time
    id: ID!
    product: Product!
    productId: Int!
    quantity: Int!
    sellingPrice: String!
    unit: Unit!
    unitId: Int!
    updatedAt: Time!
}

type Mutation {
    changePassword(input: ChangePasswordInput!): User!
    createBrand(input: BrandInput!): Brand!
    createCategory(input: CategoryInput!): Category!
    createCustomer(input: CustomerInput!): Customer!
    createExpense(input: ExpenseInput!): Expense!
    createExpensePayment(input: ExpensePaymentInput!): Payment!
    createItem(input: ItemInput!): Item!
    createOrder(input: OrderInput!): Order!
    createOrderPayment(input: OrderPaymentInput!): Payment!
    createProduct(input: ProductInput!): Product!
    createStaff(input: StaffInput!): Staff!
    createStore(input: StoreInput!): Store!
    createUnit(input: UnitInput!): Unit!
    deleteItem(id: ID!): Item!
    editBrand(id: ID!, input: BrandInput!): Brand!
    editCategory(id: ID!, input: CategoryInput!): Category!
    editCustomer(id: ID!, input: CustomerInput!): Customer!
    editItem(id: ID!, input: ItemInput!): Item!
    editOrder(id: ID!, input: OrderInput!): Order!
    editProduct(id: ID!, input: ProductInput!): Product!
    editStaff(id: ID!, input: StaffInput!): Staff!
    editStore(id: ID!, input: StoreInput!): Store!
    editUnit(id: ID!, input: UnitInput!): Unit!
    ping: String!
    signIn(input: SignInInput!): AuthPayload!
    signUp(input: SignUpInput!): AuthPayload!
    switchStore(input: SwitchStoreInput!): AuthPayload!
}

type Order implements Gorm {
    comment: String
    createdAt: Time!
    customer: Customer
    customerId: Int
    deletedAt: Time
    id: ID!
    issuer: Store!
    issuerId: Int!
    items: [OrderItem!]!
    receiver: Store
    receiverId: Int
    staff: User!
    staffId: Int!
    status: OrderStatus!
    totalPrice: String
    type: OrderType!
    updatedAt: Time!
}

type OrderItem implements Gorm {
    createdAt: Time!
    deletedAt: Time
    id: ID!
    item: Item!
    itemId: Int!
    order: Order!
    orderId: Int!
    price: String!
    quantity: Int!
    subTotalPrice: String!
    updatedAt: Time!
}

type Payment implements Gorm {
    amount: String!
    createdAt: Time!
    deletedAt: Time
    description: String
    expense: Expense
    expenseId: Int
    id: ID!
    method: PaymentMethod!
    order: Order
    orderId: Int
    referenceId: String
    staff: User!
    staffId: Int!
    updatedAt: Time!
}

type Product implements Gorm {
    brands: [Brand!]!
    createdAt: Time!
    deletedAt: Time
    id: ID!
    name: String!
    store: Store
    storeId: Int
    updatedAt: Time!
}

type ProductCategory implements Gorm {
    category: Category!
    categoryId: Int!
    createdAt: Time!
    deletedAt: Time
    id: ID!
    product: Product!
    productId: Int!
    updatedAt: Time!
}

type Query {
    admin(id: ID!): Admin!
    admins: [Admin!]!
    averageDailySalesAmount(args: StatsArgs!): String!
    brand(id: ID!): Brand!
    brands(args: BrandsArgs!): [Brand!]!
    categories: [Category!]!
    category(id: ID!): Category!
    currentStore: Store
    customer(id: ID!): Customer!
    customers: [Customer!]!
    expense(id: ID!): Expense!
    expenses(args: ExpensesArgs!): [Expense!]!
    grossIncome(args: StatsArgs!): String!
    item(id: ID!): Item!
    items(args: ItemsArgs!): [Item!]!
    me: User!
    netIncome(args: StatsArgs!): String!
    netItemsIncome: String!
    order(id: ID!): Order!
    orders(args: OrdersArgs!): [Order!]!
    payment(id: ID!): Payment!
    payments(args: PaymentsArgs!): [Payment!]!
    product(id: ID!): Product!
    products(args: ProductsArgs!): [Product!]!
    staff(id: ID!): Staff!
    staffs: [Staff!]!
    store(id: ID!): Store!
    stores: [Store!]!
    totalExpensesAmount(args: StatsArgs!): String!
    totalItemsCost: String!
    totalItemsRevenue: String!
    totalSalesAmount(args: StatsArgs!): String!
    unit(id: ID!): Unit!
    units: [Unit!]!
    user(id: ID!): User!
    users: [User!]!
}

type Staff implements Gorm {
    createdAt: Time!
    default: Boolean!
    deletedAt: Time
    id: ID!
    role: StaffRole!
    store: Store!
    storeId: Int!
    updatedAt: Time!
    user: User!
    userId: Int!
}

type Store implements Gorm {
    address: String
    businessType: BusinessType!
    createdAt: Time!
    deletedAt: Time
    description: String
    email: String
    id: ID!
    logo: String
    name: String!
    staffs: [Staff!]!
    storeType: StoreType!
    templateType: TemplateType
    tin: String
    updatedAt: Time!
    user: User!
    userId: Int!
}

type Subscription {
    item: Item!
    netProfit(args: StatsArgs!): String!
    order: Order!
    payment: Payment!
    totalExpensesAmount(args: StatsArgs!): String!
    totalSalesAmount(args: StatsArgs!): String!
}

type Unit implements Gorm {
    createdAt: Time!
    deletedAt: Time
    id: ID!
    name: String!
    store: Store
    storeId: Int
    templateType: TemplateType
    updatedAt: Time!
    user: User
    userId: Int
}

type User implements Gorm {
    createdAt: Time!
    deletedAt: Time
    email: String!
    id: ID!
    isEmailVerified: Boolean!
    isPhoneVerified: Boolean!
    isVerified: Boolean!
    name: String!
    password: String
    phone: String!
    updatedAt: Time!
    username: String
}

enum BusinessType {
    both
    retail
    wholesale
}

enum CustomerType {
    customer
    supplier
}

enum ExpenseType {
    in
    out
}

enum ExpensesBy {
    staff
    store
}

enum FetchMode {
    full
    pagination
}

enum GenderType {
    female
    male
}

enum ItemsBy {
    category
    product
    store
}

enum OrderStatus {
    canceled
    completed
    pending
}

enum OrderType {
    loss
    purchase
    sale
    transfer
}

enum OrdersBy {
    customer
    staff
    store
}

enum PaymentMethod {
    bank
    cash
    loan
}

enum PaymentType {
    expense
    order
}

enum PaymentsBy {
    customer
    staff
    store
}

enum ProductsBy {
    category
    store
}

enum SortBy {
    ASC
    DESC
}

enum StaffRole {
    owner
    staff
}

enum StoreType {
    other
    pharmacy
    shop
    storage
    warehouse
}

enum TemplateType {
    guest
    pharmacy
}

enum TimeframeType {
    lastMonth
    lastWeek
    thisMonth
    thisWeek
    thisYear
    today
    yesterday
}

scalar Time

input BrandInput {
    manufacturer: String
    name: String!
    productId: Int!
}

input BrandsArgs {
    productId: Int!
}

input CategoryInput {
    name: String!
}

input ChangePasswordInput {
    currentPassword: String!
    newPassword: String!
}

input CustomerInput {
    address: String
    dob: Time
    email: String
    gender: GenderType
    name: String!
    phone: String
    tin: String
    type: CustomerType!
}

input ExpenseInput {
    name: String!
    type: ExpenseType! = out
}

input ExpensePaymentInput {
    amount: String!
    description: String
    expenseId: Int!
    method: PaymentMethod!
    referenceId: String
}

input ExpensesArgs {
    by: ExpensesBy! = store
    limit: Int! = 10
    offset: Int! = 0
    sortBy: SortBy! = DESC
    type: ExpenseType
    value: ID!
}

input ItemInput {
    batch: String
    brandId: Int
    buyingPrice: String!
    description: String
    expiresAt: Time
    productId: Int!
    quantity: Int!
    sellingPrice: String!
    unitId: Int!
}

input ItemsArgs {
    by: ItemsBy! = store
    value: ID!
}

input OrderInput {
    comment: String
    customerId: Int
    items: [OrderItemInput!]!
    receiverId: Int
    type: OrderType!
}

input OrderItemInput {
    itemId: Int!
    price: String!
    quantity: Int!
}

input OrderPaymentInput {
    description: String
    method: PaymentMethod!
    orderId: Int!
    referenceId: String
}

input OrdersArgs {
    by: OrdersBy! = store
    endDate: Time
    limit: Int = 10
    mode: FetchMode!
    offset: Int = 0
    sortBy: SortBy = DESC
    startDate: Time
    status: OrderStatus
    timeframe: TimeframeType
    type: OrderType!
    value: ID
}

input PaymentsArgs {
    by: PaymentsBy! = store
    limit: Int! = 10
    method: PaymentMethod
    offset: Int! = 0
    sortBy: SortBy! = DESC
    type: PaymentType
    value: ID!
}

input ProductBrandInput {
    manufacturer: String
    name: String!
}

input ProductInput {
    brands: [ProductBrandInput!]
    categories: [ID!]
    name: String!
}

input ProductsArgs {
    by: ProductsBy = store
    storeType: StoreType
    value: ID
}

input SignInInput {
    login: String!
    password: String!
}

input SignUpInput {
    email: String!
    name: String!
    password: String!
    username: String
}

input StaffInput {
    role: StaffRole!
    userId: Int!
}

input StatsArgs {
    endDate: Time
    startDate: Time
    timeframe: TimeframeType
}

input StoreInput {
    address: String
    businessType: BusinessType!
    description: String
    email: String
    name: String!
    storeType: StoreType! = other
    templateType: TemplateType
    tin: String
}

input SwitchStoreInput {
    storeId: Int!
}

input UnitInput {
    name: String!
    templateType: TemplateType
}
