# GraphQL schema example
#
# https://gqlgen.com/getting-started/
interface Gorm {
    id:ID!
    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time
}

enum CustomerType {
    customer
    supplier
}

enum GenderType {
    male
    female
}

# change of status must be reflected on ledger.
enum OrderStatus {
    canceled
    completed
    pending
}

# Here we consider things in perception of where money goes (not items)
enum OrderType {
    # buying items/paying salary/expenses. Items may+, Money -.
    out
    # selling items. Items may-, Money +
    in
    # expired/damaged/stolen Items -, Money -
    loss
    # transfer from one store to another, Items neutral, Money neutral
    neutral
}

enum PaymentMethod {
    cash
    loan
    bank
}

enum StaffRole {
    # can edit things in store
    staff @enumInt(value: 2)
    # can assign users in stores
    owner @enumInt(value: 1)
}

# Having multiple type will allow transfer between parties
enum StoreType {
    pharmacy
    shop
    warehouse #
    storage # Pharmacy inner store
}

enum OrdersBy {
    customer # for customers
    staff # for who completed order
    store # for both issuers and receivers
}

enum SortBy {
    ASC
    DESC
}

# This can log via terminal
type Admin implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")

    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time

    name: String! @goTag(key: "gorm", value: "index;not null;type:varchar(50);default:null")
    email: String! @goTag(key: "gorm", value: "unique;not null;type:varchar(100);default:null")
    password: String @goTag(key: "gorm", value: "not null;type:varchar(100);default:null") @goField(forceResolver: true)
}

# With this user can reuse their credentials in different stores
type User implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")

    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time

    name: String! @goTag(key: "gorm", value: "index;not null;type:varchar(50);default:null")
    email: String! @goTag(key: "gorm", value: "unique;not null;type:varchar(100);default:null")
    username: String! @goTag(key: "gorm", value: "unique;not null;type:varchar(100);default:null")
    phone: String! @goTag(key: "gorm", value: "unique;null;type:varchar(20);default:null")
    password: String @goTag(key: "gorm", value: "not null;type:varchar(100);default:null") @goField(forceResolver: true)
}

input UserInput {
    name : String!
    username : String!
    email : String!
    password : String = password
}

input ChangePasswordInput {
    currentPassword : String!
    newPassword : String!
}


type Category implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey;")

    createdAt:Time! #@goTag(key: "gorm", value: "not null;default:null")
    updatedAt:Time! #@goTag(key: "gorm", value: "not null;default:null")
    deletedAt:Time

    # tablets/syrups/
    name: String! @goTag(key: "gorm", value: "index;not null;type:varchar(50);default:null")

    storeId: Int
    store: Store @goTag(key: "gorm", value:  "foreignKey:StoreID;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")
}

input CategoryInput {
    name: String!
    storeId: Int!
}

#todo find better name to reflect customer and supplier
type Customer implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey;")

    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time

    address: String @goTag(key: "gorm", value: "type:varchar(250);default:null")
    comment: String @goTag(key: "gorm", value: "type:varchar(250);default:null")
    email: String @goTag(key: "gorm", value: "type:varchar(100);default:null")
    name: String! @goTag(key: "gorm", value: "index;not null;type:varchar(50);default:null")
    phone: String @goTag(key: "gorm", value: "type:varchar(100);default:null")
    tin: String @goTag(key: "gorm", value: "size:50;")
    type: CustomerType!
    gender: GenderType
    dob:Time

    storeId: Int!
    store: Store! @goTag(key: "gorm", value:  "foreignKey:StoreID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    # todo Will be linked by searching phone/email above
    # todo allow email/phone number edit so that users can later be linked
    userId: Int
    user: User @goTag(key: "gorm", value:  "foreignKey:UserID;null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")
}

input CustomerInput {
    type: CustomerType!
    gender: GenderType
    dob:Time
    name: String!
    email: String
    phone: String
    address: String
    tin: String

    storeId: Int!
}

enum ExpenseType {
    out #Electucity/Water/Salary (-)
    in #cash investment in my business (+)
}

# todo Seed this with Tax, Salary, Electricity/ Water
# This should be treated like expenses category user should click electricity=> add expense
type Expense implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")

    createdAt:Time! #@goTag(key: "gorm", value: "not null;default:null")
    updatedAt:Time! #@goTag(key: "gorm", value: "not null;default:null")
    deletedAt:Time

    # This will be electricity/water/salary
    name: String! @goTag(key: "gorm", value: "index;not null;type:varchar(100);default:null")
    type: ExpenseType!

    storeId: Int!
    store: Store! @goTag(key: "gorm", value: "foreignKey:StoreID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")
}

input ExpenseInput {
    name: String!
    type: ExpenseType! = out
    storeId: ID!
}

enum ExpensesBy {
    staff # for who created expense
    store # all expenses
}

input ExpensesArgs {
    by:ExpensesBy! = store
    value:ID!
    limit: Int! =10
    offset:Int! = 0
    sortBy:SortBy! = DESC
    type:ExpenseType
}

type Product implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")

    createdAt:Time! #@goTag(key: "gorm", value: "not null;default:null")
    updatedAt:Time! #@goTag(key: "gorm", value: "not null;default:null")
    deletedAt:Time

    name: String! @goTag(key: "gorm", value: "index;not null;type:varchar(100);default:null")
    # unit box/each/package
    unit: String! @goTag(key: "gorm", value: "type:varchar(50);")

    # We will add our custom items and user may choose from our list.
    storeId: Int
    store: Store @goTag(key: "gorm", value: "foreignKey:StoreID;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    brands: [Brand!]! @goTag(key: "gorm", value: "constraint:OnUpdate:CASCADE,OnDelete:RESTRICT;") @goField(forceResolver: true)
}

input ProductInput {
    name: String!
    unit: String! # todo think of this should we have custom list?
    # user may attach more categories for the same product.
    categories: [ID!]
    # Brands can be inserted when creating product.
    storeId: ID!
    brands: [ProductBrandInput!]
}

enum ProductsBy {
    store
    category
}

input ProductsArgs {
    by: ProductsBy = store,
    value:ID
    storeType : StoreType
}

# User may create products category as they want and it will help them track them efficiently
type ProductCategory implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")

    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time

    categoryId: Int!
    category: Category! @goTag(key: "gorm", value:  "foreignKey:CategoryID;not null;constraint:OnUpdate:RESTRICT,OnDelete:CASCADE;")

    productId: Int!
    product: Product! @goTag(key: "gorm", value:  "foreignKey:ProductID;not null;constraint:OnUpdate:RESTRICT,OnDelete:CASCADE;")
}

# Product can be the same but with different brands
type Brand implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")

    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time

    name: String! @goTag(key: "gorm", value: "index;not null;type:varchar(50);default:null")
    manufacturer: String @goTag(key: "gorm", value: "type:varchar(50);default:null")

    productId: Int!
    product: Product! @goTag(key: "gorm", value:  "foreignKey:ProductID;")
}

# This is used to create brand when creating product itself.
input ProductBrandInput {
    name: String!
    manufacturer: String
}

input BrandInput {
    name: String!
    manufacturer: String
    productId: Int!
}

# todo: expenses items should also come as items.
type Item implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")

    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time

    quantity: Int!  @goTag(key: "gorm", value: "type:integer;not null;unsigned;")
    batch: String @goTag(key: "gorm", value: "index;type:varchar(50);")
    description: String @goTag(key: "gorm", value: "size:100")
    # Prices should be zero for non expenses
    # empty string for non admins
    buyingPrice: String!  @goTag(key: "gorm", value: "type:numeric;not null;unsigned") @goField(forceResolver: true)
    sellingPrice: String!  @goTag(key: "gorm", value: "type:numeric;not null;unsigned")
    expiresAt: Time!

    # Here we will concatenate brand if available and product name
    name: String!  @goTag(key: "gorm", value: "-") @goField(forceResolver: true)

    productId: Int!
    product: Product! @goTag(key: "gorm", value:  "foreignKey:ProductID;not null;constraint:OnUpdate:RESTRICT,OnDelete:CASCADE;")

    # todo make it nullable when brand is deleted
    brandId: Int
    brand: Brand @goTag(key: "gorm", value:  "foreignKey:BrandID;constraint:OnUpdate:RESTRICT,OnDelete:CASCADE;")
}

input ItemInput {
    quantity: Int!
    buyingPrice: String!
    sellingPrice: String!
    batch: String
    description: String
    expiresAt: Time

    brandId: Int
    productId: Int!
}

enum ItemsBy {
    store
    category
    product
}

input ItemsArgs {
    by:ItemsBy! = store,
    value:ID!
}

# Even suppliers/customers can be termed as staffs
# todo we should allow specifying name here may be for handling customers
type Staff implements Gorm {
    id: ID! @goTag(key: "gorm", value: "primaryKey")

    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time
    # null means user has not been configured yet.
    role: StaffRole! #@goTag(key: "gorm", value: "type:SMALLINT")

    userId: Int!
    user: User! @goTag(key: "gorm", value: "foreignKey:UserID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    storeId: Int!
    store: Store! @goTag(key: "gorm", value: "foreignKey:StoreID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")
}

input StaffInput {
    storeId: Int!
    userId: Int!
}


# add tracking type package/tabs
type Store implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")

    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time

    address: String @goTag(key: "gorm", value: "size:100;")
    # This will stay under title.
    description: String @goTag(key: "gorm", value: "size:100;")
    email: String @goTag(key: "gorm", value: "size:100;")
    logo: String @goTag(key: "gorm", value: "size:100;")
    name: String! @goTag(key: "gorm", value: "index;size:50;not null;default:null")
    #phones: [String!] @goTag(key: "gorm", value: "size:50;")
    tin: String @goTag(key: "gorm", value: "size:50;")
    type: StoreType

    ownerId: Int!
    owner: User! @goTag(key: "gorm", value: "foreignKey:OwnerID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    staffs: [Staff!]! @goTag(key: "gorm", value: "-")
}

input StoreInput {
    address: String
    # This will stay under title.
    description: String
    email: String
    name: String!
    #phones: [String!] @goTag(key: "gorm", value: "size:50;")
    tin: String
    type: StoreType
}

type Order implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")

    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time

    # Here we will sum all items price
    totalPrice: String @goTag(key: "gorm", value: "-") @goField(forceResolver: true)
    type: OrderType!
    status: OrderStatus! @goTag(key: "gorm", value: "size:100")
    comment: String @goTag(key: "gorm", value: "size:100")

    # todo depending on order type this can be supplier
    # Customer can be nullable. Since POS don't have to register customer.
    customerId: Int
    customer: Customer @goTag(key: "gorm", value: "foreignKey:CustomerID;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    staffId: Int!
    staff: User! @goTag(key: "gorm", value: "foreignKey:StaffID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    # Where products come from
    issuerId: Int!
    issuer: Store! @goTag(key: "gorm", value: "foreignKey:IssuerID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    # todo if we transfer to different owner's store I think approve is must before altering stock
    # This is not null in transfer
    receiverId: Int
    receiver: Store @goTag(key: "gorm", value: "foreignKey:ReceiverID;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    items: [OrderItem!]! @goTag(key: "gorm", value: "constraint:OnUpdate:CASCADE,OnDelete:RESTRICT;") @goField(forceResolver: true)
}

input OrderInput {
    type: OrderType!
    issuerId: Int!
    customerId: Int
    receiverId: Int
    comment: String
    items: [OrderItemInput!]!
}

input OrdersArgs {
    by:OrdersBy! = store
    value:ID!
    limit: Int! =10
    offset:Int! = 0
    sortBy:SortBy! = DESC
    type:OrderType! = in
    status:OrderStatus
}

type OrderItem implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")

    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time

    quantity: Int! @goTag(key: "gorm", value: "type:integer;not null")
    # user may be given discount. This price of just one item
    price: String! @goTag(key: "gorm", value: "type:numeric;not null")
    # This equals to sellingPrice * quantity
    subTotalPrice: String! @goField(forceResolver: true) @goTag(key: "gorm", value: "-")

    itemId: Int!
    item: Item! @goTag(key: "gorm", value:  "foreignKey:ItemID;not null;constraint:OnUpdate:RESTRICT,OnDelete:CASCADE;")

    orderId: Int!
    order: Order! @goTag(key: "gorm", value:  "foreignKey:OrderID;not null;")
}

input OrderItemInput {
    quantity: Int!
    # Just price because it can be buying/selling
    price: String!
    itemId: Int!
}

# todo for tracking expenses we need to add product either here or in orders
type Payment implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")

    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time

    amount: String! @goTag(key: "gorm", value: "type:numeric;not null")
    # In expenses description will describe in details where everything goes
    description: String @goTag(key: "gorm", value: "size:250")
    # Id to identify this payment
    referenceId: String @goTag(key: "gorm", value: "index;size:50")
    method: PaymentMethod!

    staffId: Int!
    staff: User! @goTag(key: "gorm", value: "foreignKey:StaffID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    # We will know either it is product/expense depending on what is null
    # Payment for what order.
    orderId: Int
    order: Order @goTag(key: "gorm", value: "foreignKey:OrderID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    expenseId: Int
    expense: Expense @goTag(key: "gorm", value: "foreignKey:ExpenseID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")
}

# This is used for completing order and tracking expenses..
input OrderPaymentInput  {
    orderId: Int!
    description: String
    referenceId: String
    method: PaymentMethod!
}

input ExpensePaymentInput {
    expenseId: Int!
    description: String
    referenceId: String
    method: PaymentMethod!
    amount: String!
}

enum PaymentsBy {
    staff # for who created expense
    store # all expenses
    customer
}

enum PaymentType {
    expense
    order
}

input PaymentsArgs {
    by:PaymentsBy! = store
    value: ID!
    limit: Int! =10
    offset: Int! = 0
    sortBy: SortBy! = DESC
    method: PaymentMethod
    type: PaymentType
}

type Stats {
    profit(startDate:Time!,endDate:Time!): String! @goField(forceResolver: true)
    totalSalesAmount(startDate:Time!,endDate:Time!): String! @goField(forceResolver: true)
    totalSalesItems(startDate:Time!,endDate:Time!): String! @goField(forceResolver: true)
}

type Query {
    admin(id:ID!): Admin!
    admins: [Admin!]!
    brand(id:ID!): Brand!
    brands(productId:ID!): [Brand!]!
    category(id:ID!): Category!
    categories(storeId:ID!): [Category!]!
    customer(id:ID!): Customer!
    customers(storeId:ID!): [Customer!]!
    item(id: ID!): Item!
    items(args: ItemsArgs!): [Item!]!
    expense(id: ID!): Expense!
    expenses(args: ExpensesArgs!): [Expense!]! #for getting kinda expenses categories
    order(id: ID!): Order!
    orders(args: OrdersArgs!): [Order!]!
    payment(id: ID!): Payment!
    payments(args: PaymentsArgs!): [Payment!]!
    product(id: ID!): Product!
    products(args: ProductsArgs!): [Product!]!
    staff(id: ID!): Staff!
    staffs(storeId:ID!): [Staff!]!
    store(id: ID!): Store!
    stores: [Store!]!
    user(id: ID!): User!
    users: [User!]!
}

type Mutation {
    createBrand(input: BrandInput!): Brand! @hasRole(role: owner)
    createCategory(input: CategoryInput!): Category! @hasRole(role: owner)
    createCustomer(input: CustomerInput!): Customer! @hasRole(role: owner)
    createExpense(input: ExpenseInput!): Expense! @hasRole(role: owner)
    createItem(input: ItemInput!): Item! @hasRole(role: owner)
    createOrder(input: OrderInput!): Order!
    createOrderPayment(input: OrderPaymentInput!): Payment! @hasRole(role: staff)
    createExpensePayment(input: ExpensePaymentInput!): Payment! @hasRole(role: staff)
    createProduct(input: ProductInput!): Product! @hasRole(role: owner)
    createStaff(input: StaffInput!): Staff! @hasRole(role: owner)
    createStore(input: StoreInput!): Store! @hasRole(role: owner)
    # Only admins can create new user.
    createUser(input: UserInput!): User! @hasRole(role: owner)

    changePassword(input: ChangePasswordInput!): User!

    editBrand(id: ID!,input: BrandInput!): Brand! @hasRole(role: owner)
    editCategory(id: ID!,input: CategoryInput!): Category! @hasRole(role: owner)
    editCustomer(id: ID!,input: CustomerInput!): Customer! @hasRole(role: owner)
    editItem(id: ID!,input: ItemInput!): Item! @hasRole(role: owner)
    editOrder(id: ID!,input: OrderInput!): Order!
    editProduct(id: ID!,input: ProductInput!): Product!
    editStaff(id: ID!,input: StaffInput!): Staff! @hasRole(role: owner)
    editStore(id: ID!,input: StoreInput!): Store! @hasRole(role: owner)
    editUser(id: ID!,input: UserInput!): User!

    deleteItem(id: ID!): Item! @hasRole(role: owner)

    # For testing if local ip works. Otherwise client will have to reconfigure.
    ping: String!

    signUp(input: UserInput): User
}

scalar Time

directive @goModel(
    model: String
    models: [String!]
) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION

directive @goField(
    forceResolver: Boolean
    name: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

directive @goTag(
    key: String!
    value: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

directive @hasRole(role: StaffRole!) on FIELD_DEFINITION
directive @E on ENUM_VALUE