# GraphQL schema example
#
# https://gqlgen.com/getting-started/
interface Gorm {
    id:ID!
    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time
}

enum CustomerType {
    customer
    supplier
}

enum GenderType {
    male
    female
}

# change of status must be reflected on ledger.
enum OrderStatus {
    canceled
    completed
    pending
}

# Here we consider things in perception of where money goes (not items)
enum OrderType {
    # buying items/paying salary/expenses. Items may+, Money -.
    sale
    # selling items. Items may-, Money +
    purchase
    # expired/damaged/stolen Items -, Money -
    loss
    # transfer from one store to another, Items neutral, Money neutral
    transfer
}

enum PaymentMethod {
    cash
    loan
    bank
}

# Having multiple type will allow transfer between parties
enum StoreType {
    pharmacy
    shop
    warehouse #
    storage # Pharmacy inner store
    other
}

enum TemplateType {
    pharmacy
    guest
}

enum BusinessType {
    retail
    wholesale
    both
}

enum OrdersBy {
    customer # for customers
    staff # for who completed order
    store # for both issuers and receivers
}

enum SortBy {
    ASC
    DESC
}

# This can log via terminal
type Admin implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")

    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time

    name: String! @goTag(key: "gorm", value: "index;not null;type:varchar(50);default:null")
    email: String! @goTag(key: "gorm", value: "unique;not null;type:varchar(100);default:null")
    password: String @goTag(key: "gorm", value: "not null;type:varchar(100);default:null") @goField(forceResolver: true)
}

# With this user can reuse their credentials in different stores
type User implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")

    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time

    name: String! @goTag(key: "gorm", value: "index;not null;type:varchar(50);default:null")
    email: String! @goTag(key: "gorm", value: "unique;not null;type:varchar(100);default:null")
    username: String @goTag(key: "gorm", value: "unique;type:varchar(100);default:null")
    phone: String! @goTag(key: "gorm", value: "unique;null;type:varchar(20);default:null")
    password: String @goTag(key: "gorm", value: "type:varchar(100);default:null") @goField(forceResolver: true)

    isVerified: Boolean! @goTag(key: "gorm", value: "not null;default:false")
    isEmailVerified: Boolean! @goTag(key: "gorm", value: "not null;default:false")
    isPhoneVerified: Boolean! @goTag(key: "gorm", value: "not null;default:false")
}

input SignInInput {
    login: String! @validate(constraint: "required")
    password: String! @validate(constraint: "required")
}

input SignUpInput {
    name : String! @validate(constraint: "required")
    username : String #@validate(constraint: "optional")
    email : String! @validate(constraint: "required,email")
    password : String! @validate(constraint: "required")
}

input SwitchStoreInput {
    storeId: Int!
}

# We are not using cookies because most apps won't be browser based apps
type AuthPayload {
    accessToken : String!
    user: User! @goField(forceResolver: true)
    # This returns the default store todo remove it it's just confusing
    store: Store @goField(forceResolver: true)
}

type AuthParams {
    userId: Int!
    storeId: Int! #ensure 0 is not used
    role : StaffRole!
}

input ChangePasswordInput {
    currentPassword : String!
    newPassword : String!
}


type Category implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey;")

    createdAt:Time! #@goTag(key: "gorm", value: "not null;default:null")
    updatedAt:Time! #@goTag(key: "gorm", value: "not null;default:null")
    deletedAt:Time

    # tablets/syrups/
    name: String! @goTag(key: "gorm", value: "index;not null;type:varchar(50);default:null")

    creatorId: Int
    creator: User @goTag(key: "gorm", value: "foreignKey:CreatorID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    storeId: Int
    store: Store @goTag(key: "gorm", value:  "foreignKey:StoreID;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")
}

input CategoryInput {
    name: String!
}

#todo find better name to reflect customer and supplier
type Customer implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey;")

    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time

    address: String @goTag(key: "gorm", value: "type:varchar(250);default:null")
    comment: String @goTag(key: "gorm", value: "type:varchar(250);default:null")
    email: String @goTag(key: "gorm", value: "type:varchar(100);default:null")
    name: String! @goTag(key: "gorm", value: "index;not null;type:varchar(50);default:null")
    phone: String @goTag(key: "gorm", value: "type:varchar(100);default:null")
    tin: String @goTag(key: "gorm", value: "size:50;")
    type: CustomerType!
    gender: GenderType
    dob:Time

    storeId: Int!
    store: Store! @goTag(key: "gorm", value:  "foreignKey:StoreID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    # todo Will be linked by searching phone/email above
    # todo allow email/phone number edit so that users can later be linked
    userId: Int
    user: User @goTag(key: "gorm", value:  "foreignKey:UserID;null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    creatorId: Int
    creator: User @goTag(key: "gorm", value: "foreignKey:CreatorID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")
}

input CustomerInput {
    type: CustomerType!
    gender: GenderType
    dob:Time
    name: String!
    email: String
    phone: String
    address: String
    tin: String
}

enum ExpenseType {
    out #Electucity/Water/Salary (-)
    in #cash investment in my business (+)
}

# todo Seed this with Tax, Salary, Electricity/ Water
# This should be treated like expenses category user should click electricity=> add expense
type Expense implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")

    createdAt:Time! #@goTag(key: "gorm", value: "not null;default:null")
    updatedAt:Time! #@goTag(key: "gorm", value: "not null;default:null")
    deletedAt:Time

    # This will be electricity/water/salary
    name: String! @goTag(key: "gorm", value: "index;not null;type:varchar(100);default:null")
    type: ExpenseType!

    storeId: Int!
    store: Store! @goTag(key: "gorm", value: "foreignKey:StoreID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    creatorId: Int
    creator: User @goTag(key: "gorm", value: "foreignKey:CreatorID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")
}

input ExpenseInput {
    name: String!
    type: ExpenseType! = out
}

enum ExpensesBy {
    staff # for who created expense
    store # all expenses
}

input ExpensesArgs {
    by:ExpensesBy! = store
    value:ID
    sortBy:SortBy = DESC
    type:ExpenseType
}

type Product implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")

    createdAt:Time! #@goTag(key: "gorm", value: "not null;default:null")
    updatedAt:Time! #@goTag(key: "gorm", value: "not null;default:null")
    deletedAt:Time

    name: String! @goTag(key: "gorm", value: "index;not null;type:varchar(100);default:null")
    description: String @goTag(key: "gorm", value: "")

    # We will add our custom items and user may choose from our list.
    storeId: Int
    store: Store @goTag(key: "gorm", value: "foreignKey:StoreID;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    brands: [Brand!]! @goTag(key: "gorm", value: "constraint:OnUpdate:CASCADE,OnDelete:RESTRICT;") @goField(forceResolver: true)

    creatorId: Int
    creator: User @goTag(key: "gorm", value: "foreignKey:CreatorID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")
}

input ProductInput {
    name: String!
    # user may attach more categories for the same product.
    categories: [ID!]
    # Brands can be inserted when creating product.
    brands: [ProductBrandInput!]
    description: String
}

enum ProductsBy {
    store
    category
}

input ProductsArgs {
    by: ProductsBy = store,
    value:ID
    storeType : StoreType
}

# User may create products category as they want and it will help them track them efficiently
type ProductCategory implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")

    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time

    categoryId: Int!
    category: Category! @goTag(key: "gorm", value:  "foreignKey:CategoryID;not null;constraint:OnUpdate:RESTRICT,OnDelete:CASCADE;")

    productId: Int!
    product: Product! @goTag(key: "gorm", value:  "foreignKey:ProductID;not null;constraint:OnUpdate:RESTRICT,OnDelete:CASCADE;")

    creatorId: Int
    creator: User @goTag(key: "gorm", value: "foreignKey:CreatorID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")
}

# Product can be the same but with different brands
type Brand implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")

    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time

    name: String! @goTag(key: "gorm", value: "index;not null;type:varchar(50);default:null")
    manufacturer: String @goTag(key: "gorm", value: "type:varchar(50);default:null")

    productId: Int!
    product: Product! @goTag(key: "gorm", value:  "foreignKey:ProductID;")

    creatorId: Int
    creator: User @goTag(key: "gorm", value: "foreignKey:CreatorID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")
}

# This is used to create brand when creating product itself.
input ProductBrandInput {
    name: String!
    manufacturer: String
}

input BrandInput {
    name: String!
    manufacturer: String
    productId: Int!
}

input BrandsArgs {
    productId: Int
}

# todo: expenses items should also come as items.
# this should be tracked as whole, so we just decrease amount not increment them.
# no editing stock kizembe so as it will easy tracking where items went
type Item implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")

    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time

    quantity: Int!  @goTag(key: "gorm", value: "type:integer;not null;unsigned;")
    batch: String @goTag(key: "gorm", value: "index;type:varchar(50);")
    description: String @goTag(key: "gorm", value: "size:100")
    # Prices should be zero for non expenses
    # empty string for non admins
    buyingPrice: String!  @goTag(key: "gorm", value: "type:numeric;not null;unsigned") @goField(forceResolver: true)
    sellingPrice: String!  @goTag(key: "gorm", value: "type:numeric;not null;unsigned")
    expiresAt: Time

    creatorId: Int
    creator: User @goTag(key: "gorm", value: "foreignKey:CreatorID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    productId: Int!
    product: Product! @goTag(key: "gorm", value:  "foreignKey:ProductID;not null;constraint:OnUpdate:RESTRICT,OnDelete:CASCADE;") @goField(forceResolver: true)

    # todo make it nullable when brand is deleted
    brandId: Int
    brand: Brand @goTag(key: "gorm", value:  "foreignKey:BrandID;constraint:OnUpdate:RESTRICT,OnDelete:CASCADE;") @goField(forceResolver: true)

    unitId: Int!
    unit: Unit! @goTag(key: "gorm", value:  "foreignKey:UnitID;not null;constraint:OnUpdate:RESTRICT,OnDelete:CASCADE;") @goField(forceResolver: true)
}

input ItemInput {
    unitId: Int!
    quantity: Int!
    buyingPrice: String!
    sellingPrice: String!
    batch: String
    description: String
    expiresAt: Time

    brandId: Int
    productId: Int!
}

enum ItemsBy {
    store
    category
    product
}

input ItemsArgs {
    by:ItemsBy! = store,
    value:ID!
}

enum StaffRole {
    # can edit things in store
    staff @enumInt(value: 2)
    # can assign users in stores
    owner @enumInt(value: 1)
}

# Even suppliers/customers can be termed as staffs
# todo we should allow specifying name here may be for handling customers
type Staff implements Gorm {
    id: ID! @goTag(key: "gorm", value: "primaryKey")

    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time
    # null means user has not been configured yet.
    role: StaffRole! #@goTag(key: "gorm", value: "type:SMALLINT")

    # Defaults store when user logs in like youtube
    default: Boolean! @goTag(key: "gorm", value: "type:boolean")

    userId: Int!
    user: User! @goTag(key: "gorm", value: "foreignKey:UserID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    storeId: Int!
    store: Store! @goTag(key: "gorm", value: "foreignKey:StoreID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    creatorId: Int
    creator: User @goTag(key: "gorm", value: "foreignKey:CreatorID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")
}

input StaffInput {
    userId: Int!
    role: StaffRole!
}


# add tracking type package/tabs
type Store implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")

    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time

    # This will stay under title.
    description: String @goTag(key: "gorm", value: "size:150;")
    terms: String @goTag(key: "gorm", value: "size:150;")
    logo: String @goTag(key: "gorm", value: "size:100;")
    name: String! @goTag(key: "gorm", value: "index;size:50;not null;default:null")
    tin: String @goTag(key: "gorm", value: "size:50;")
    storeType: StoreType!
    businessType: BusinessType!

    #user may remove this option to remove our products suggestions
    templateType : TemplateType

    # Creator of store
    userId: Int!
    user: User! @goTag(key: "gorm", value: "foreignKey:UserID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    staffs: [Staff!]! @goTag(key: "gorm", value: "-")
}

input StoreInput {
    # This will stay under title.
    description: String
    terms: String
    name: String!
    tin: String
    storeType: StoreType! = other
    businessType: BusinessType!
    templateType : TemplateType
}

type Order implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")

    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time

    # Here we will sum all items price
    totalPrice: String @goTag(key: "gorm", value: "-") @goField(forceResolver: true)
    type: OrderType!
    status: OrderStatus! @goTag(key: "gorm", value: "size:100")
    comment: String @goTag(key: "gorm", value: "size:100")

    # todo depending on order type this can be supplier
    # Customer can be nullable. Since POS don't have to register customer.
    customerId: Int
    customer: Customer @goTag(key: "gorm", value: "foreignKey:CustomerID;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;") @goField(forceResolver: true)

    staffId: Int!
    staff: User! @goTag(key: "gorm", value: "foreignKey:StaffID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;") @goField(forceResolver: true)

    # Where products come from
    issuerId: Int!
    issuer: Store! @goTag(key: "gorm", value: "foreignKey:IssuerID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;") @goField(forceResolver: true)

    # todo if we transfer to different owner's store I think approve is must before altering stock
    # This is not null in transfer
    receiverId: Int
    receiver: Store @goTag(key: "gorm", value: "foreignKey:ReceiverID;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;") @goField(forceResolver: true)

    orderItems: [OrderItem!]! @goTag(key: "gorm", value: "constraint:OnUpdate:CASCADE,OnDelete:RESTRICT;") @goField(forceResolver: true)

    payment: Payment @goTag(key: "gorm",value: "-") @goField(forceResolver: true)
}

input OrderInput {
    type: OrderType!
    customerId: Int @validate(constraint: "required")
    receiverId: Int
    comment: String
    items: [OrderItemInput!]!
}

input SalesInput {
    comment: String
    items: [OrderItemInput!]!
}

# This will decide whether result will be handled in full or by pagination
enum FetchMode {
    pagination
    full
}

input OrdersArgs {
    mode:FetchMode!
    by:OrdersBy! = store
    value:ID
    limit: Int =10
    offset:Int = 0
    sortBy:SortBy = DESC
    type:OrderType!
    status:OrderStatus
    startDate:Time
    endDate:Time
    timeframe: TimeframeType
}

type OrderItem implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")

    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time

    quantity: Int! @goTag(key: "gorm", value: "type:integer;not null")
    # user may be given discount. This price of just one item
    price: String! @goTag(key: "gorm", value: "type:numeric;not null")
    # This equals to sellingPrice * quantity
    subTotalPrice: String! @goField(forceResolver: true) @goTag(key: "gorm", value: "-")

    itemId: Int!
    item: Item! @goTag(key: "gorm", value:  "foreignKey:ItemID;not null;constraint:OnUpdate:RESTRICT,OnDelete:CASCADE;") @goField(forceResolver: true)

    orderId: Int!
    order: Order! @goTag(key: "gorm", value:  "foreignKey:OrderID;not null;")
}

input OrderItemInput {
    quantity: Int!
    # Just price because it can be buying/selling
    price: String!
    itemId: Int!
}

# todo for tracking expenses we need to add product either here or in orders
type Payment implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")

    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time

    amount: String! @goTag(key: "gorm", value: "type:numeric;not null")
    # In expenses description will describe in details where everything goes
    description: String @goTag(key: "gorm", value: "size:250")
    # Id to identify this payment
    referenceId: String @goTag(key: "gorm", value: "index;size:50")
    # If posting to TRA will result in some kind of receipt then we will save it here
    receiptId: String @goTag(key: "gorm", value: "index;size:50")
    method: PaymentMethod!
    type: PaymentType! @goTag(key: "gorm",value: "-") @goField(forceResolver: true)
    name : String! @goTag(key: "gorm",value: "-") @goField(forceResolver: true)

    staffId: Int!
    staff: User! @goTag(key: "gorm", value: "foreignKey:StaffID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;") @goField(forceResolver: true)

    # We will know either it is product/expense depending on what is null
    # Payment for what order.
    orderId: Int
    order: Order @goTag(key: "gorm", value: "foreignKey:OrderID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;") @goField(forceResolver: true)

    expenseId: Int
    expense: Expense @goTag(key: "gorm", value: "foreignKey:ExpenseID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;") @goField(forceResolver: true)

    orderItems: [OrderItem!] @goField(forceResolver: true) @goTag(key: "gorm",value: "-")
}

# This is used for completing order and tracking expenses..
input OrderPaymentInput  {
    orderId: Int!
    description: String
    referenceId: String
    method: PaymentMethod!
}

input ExpensePaymentInput {
    expenseId: Int!
    description: String
    referenceId: String
    method: PaymentMethod!
    amount: String!
}

enum PaymentsBy {
    staff # for who created expense
    store # all expenses
    customer
}

# todo add rename to in/out
enum PaymentType {
    expense
    order
}

input PaymentsArgs {
    mode:FetchMode!
    by:PaymentsBy! = store
    value: ID
    limit: Int =10
    offset: Int = 0
    sortBy: SortBy = DESC
    method: PaymentMethod
    type: PaymentType
    timeframe: TimeframeType
    startDate:Time
    endDate:Time
}

enum TimeframeType {
    today
    yesterday
    thisWeek
    lastWeek
    thisMonth
    lastMonth
    thisYear
}

# We may use duration
input StatsArgs {
    startDate:Time
    endDate:Time
    timeframe: TimeframeType
}

# We will seed common units and each store can add more units to fit their needs
# todo add suggestions based on template
type Unit implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey;")

    createdAt:Time! #@goTag(key: "gorm", value: "not null;default:null")
    updatedAt:Time! #@goTag(key: "gorm", value: "not null;default:null")
    deletedAt:Time

    # tablets/syrups/
    name: String! @goTag(key: "gorm", value: "index;not null;type:varchar(20);default:null")

    #We will add common units based on this
    templateType : TemplateType

    storeId: Int
    store: Store @goTag(key: "gorm", value:  "foreignKey:StoreID;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    userId: Int
    user: User @goTag(key: "gorm", value:  "foreignKey:UserID;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")
}

input UnitInput {
    name: String!
    templateType : TemplateType
}

type Profit {
    # Profit without discount
    expected : String!
    # With discount
    real : String!
}

type ItemsStats {
    expectedProfit : String!
    totalCost : String!
    totalReturn : String!
}

#todo remove storeId everywhere and use JWT for that.
type Query {
    admin(id:ID!): Admin!
    admins: [Admin!]!
    brand(id:ID!): Brand!
    brands(args:BrandsArgs!): [Brand!]!
    category(id:ID!): Category!
    categories: [Category!]! @isAuthenticated
    currentStore: Store @isAuthenticated
    customer(id:ID!): Customer!
    customers: [Customer!]! @isAuthenticated
    item(id: ID!): Item!
    items(args: ItemsArgs!): [Item!]! @isAuthenticated
    expense(id: ID!): Expense!
    expenses(args: ExpensesArgs!): [Expense!]! @isAuthenticated  #for getting kinda expenses categories
    me: User! @isAuthenticated
    order(id: ID!): Order! @isAuthenticated
    orders(args: OrdersArgs!): [Order!]! @isAuthenticated
    payment(id: ID!): Payment! @isAuthenticated
    payments(args: PaymentsArgs!): [Payment!]! @isAuthenticated
    product(id: ID!): Product!
    products(args: ProductsArgs!): [Product!]!
    staff(id: ID!): Staff! @isAuthenticated
    staffs: [Staff!]! @isAuthenticated
    store(id: ID!): Store! @isAuthenticated
    stores: [Store!]! @isAuthenticated
    unit(id: ID!): Unit!
    units: [Unit!]! @isAuthenticated
    user(id: ID!): User!
    users: [User!]! #todo add args  @isAuthenticated

    # stats
    netIncome(args:StatsArgs!): String! @goField(forceResolver: true) @isAuthenticated
    grossProfit(args:StatsArgs!): Profit! @goField(forceResolver: true) @isAuthenticated
    totalExpensesAmount(args:StatsArgs!): String! @goField(forceResolver: true) @isAuthenticated
    totalSalesAmount(args:StatsArgs!): String! @goField(forceResolver: true) @isAuthenticated
    # Daily sales
    averageDailySalesAmount(args:StatsArgs!): String! @goField(forceResolver: true) @isAuthenticated
    #cost of buying goods
    itemsStats: ItemsStats! @goField(forceResolver: true) @isAuthenticated
}

type Mutation {
    createBrand(input: BrandInput!): Brand! @isAuthenticated @hasRole(role: owner)
    createCategory(input: CategoryInput!): Category! @isAuthenticated @hasRole(role: owner)
    createCustomer(input: CustomerInput!): Customer! @isAuthenticated  @hasRole(role: staff)
    createExpense(input: ExpenseInput!): Expense! @isAuthenticated  @hasRole(role: owner)
    createItem(input: ItemInput!): Item! @isAuthenticated  @hasRole(role: owner)
    createOrder(input: OrderInput!): Order! @isAuthenticated @hasRole(role: staff)
    createOrderPayment(input: OrderPaymentInput!): Payment! @isAuthenticated  @hasRole(role: staff)
    createExpensePayment(input: ExpensePaymentInput!): Payment! @isAuthenticated  @hasRole(role: staff)
    createProduct(input: ProductInput!): Product! @isAuthenticated  @hasRole(role: owner)
    createSales(input: SalesInput!): Payment! @isAuthenticated  @hasRole(role: staff)
    createStaff(input: StaffInput!): Staff! @isAuthenticated  @hasRole(role: owner)
    createStore(input: StoreInput!): Store! @isAuthenticated
    # Only admins can create new user.
    createUnit(input: UnitInput!): Unit! @isAuthenticated  @hasRole(role: owner)

    changePassword(input: ChangePasswordInput!): User! @isAuthenticated

    editBrand(id: ID!,input: BrandInput!): Brand! @isAuthenticated  @hasRole(role: owner)
    editCategory(id: ID!,input: CategoryInput!): Category! @isAuthenticated  @hasRole(role: owner)
    editCustomer(id: ID!,input: CustomerInput!): Customer! @isAuthenticated  @hasRole(role: staff)
    editItem(id: ID!,input: ItemInput!): Item! @isAuthenticated  @hasRole(role: owner)
    editOrder(id: ID!,input: OrderInput!): Order!  @isAuthenticated
    editProduct(id: ID!,input: ProductInput!): Product!  @isAuthenticated
    editStaff(id: ID!,input: StaffInput!): Staff! @isAuthenticated  @hasRole(role: owner)
    editStore(id: ID!,input: StoreInput!): Store! @isAuthenticated  @hasRole(role: owner)
    editUnit(id: ID!,input: UnitInput!): Unit! @isAuthenticated  @hasRole(role: owner)

    deleteItem(id: ID!): Item!  @isAuthenticated @hasRole(role: owner)

    # For testing if local ip works. Otherwise client will have to reconfigure.
    ping: String!

    signIn(input: SignInInput!): AuthPayload!
    signUp(input: SignUpInput!): AuthPayload!
    switchStore(input: SwitchStoreInput!): AuthPayload! @isAuthenticated
}

type Subscription {
    item: Item! # When we edit/add item
    order: Order! @isAuthenticated #when order is edited/created
    payment: Payment! @isAuthenticated #when new payment is made

    netProfit(args:StatsArgs!): String! @goField(forceResolver: true) @isAuthenticated
    totalExpensesAmount(args:StatsArgs!): String! @goField(forceResolver: true) @isAuthenticated
    totalSalesAmount(args:StatsArgs!): String! @goField(forceResolver: true) @isAuthenticated
}

scalar Time

directive @goModel(
    model: String
    models: [String!]
) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION

directive @goField(
    forceResolver: Boolean
    name: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

directive @goTag(
    key: String!
    value: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

directive @hasRole(role: StaffRole!) on FIELD_DEFINITION
directive @isAuthenticated on FIELD_DEFINITION

directive @validate(constraint: String!) on INPUT_FIELD_DEFINITION | ARGUMENT_DEFINITION
directive @id on INPUT_FIELD_DEFINITION | ARGUMENT_DEFINITION
