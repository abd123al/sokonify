# GraphQL schema example
#
# https://gqlgen.com/getting-started/
interface Gorm {
    id:ID!
    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time
}

enum OrderType {
    # order for receiving items
    purchase
    # order for selling items
    sale
    # Let's say we pay for some things eg electricity.
    expense
    # If things have expired they can be automatically disposed.
    # todo we should have cron job for doing this.
    expired
    damaged
}

enum PaymentType {
    cash
    loan
    bank
}

enum UserType {
    # can change system settings and assigning employers
    admin
    # who buys
    customer
    # can edit things in store
    staff
    # can assign users in stores
    owner
    # who brings products in
    supplier
}

# Having multiple type will allow transfer between parties
enum StoreType {
    shop
    warehouse
}

# With this user can reuse their credentials in different stores
type User implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")
    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time # @goTag(key: "faker",value: "time")
    name: String! @goTag(key: "gorm", value: "index;size:50") @goTag(key: "faker",value: "name")
    email: String! @goTag(key: "gorm", value: "unique;size:100") @goTag(key: "faker",value: "email")
    username: String! @goTag(key: "gorm", value: "unique;size:20") @goTag(key: "faker",value: "username")
    password: String @goTag(key: "gorm", value: "size:100") @goField(forceResolver: true) @goTag(key: "faker",value: "password")
    # null means user has not been configured yet.
    type: UserType @goTag(key: "sql", value: "type:user_type")
}

input UserInput {
    name : String!
    username : String!
    email : String!
    password : String = password
}

input ChangePasswordInput {
    currentPassword : String!
    newPassword : String!
}


type Category implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey;type:integer")
    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time

    # tablets/syrups/
    name: String! @goTag(key: "gorm", value: "index;size:50")
    # unit box/each/package
    unit: String @goTag(key: "gorm", value: "size:50;")

    storeId: Int!
    store: Store! @goTag(key: "gorm", value:  "foreignKey:StoreID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")
}

input CategoryInput {
    name: String!
    unit: String

    storeId: Int!
}

type Product implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")
    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time

    name: String! @goTag(key: "gorm", value: "index;size:100")

    categoryId: Int!
    category: Category! @goTag(key: "gorm", value:  "foreignKey:CategoryID;not null;constraint:OnUpdate:RESTRICT,OnDelete:CASCADE;")
}

input ProductInput {
    name: String!
    categoryId: Int!
    # Brands can be inserted when creating product.
    brands: [ProductBrandInput!]
}

# Product can be the same but with different brands
type Brand implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")
    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time

    name: String! @goTag(key: "gorm", value: "index;size:50")
    manufacturer: String @goTag(key: "gorm", value: "size:50")

    productId: Int!
    product: Product! @goTag(key: "gorm", value:  "foreignKey:ProductID;not null;constraint:OnUpdate:RESTRICT,OnDelete:CASCADE;")
}

# This is used to create brand when creating product itself.
input ProductBrandInput {
    name: String!
    manufacturer: String
}

input BrandInput {
    name: String!
    manufacturer: String
    productId: Int!
}

type Item implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")
    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time

    quantity: Int!  @goTag(key: "gorm", value: "type:integer;")
    batch: String @goTag(key: "gorm", value: "size:50")
    # nullable for non admins
    buyingPrice: String  @goTag(key: "gorm", value: "type:numeric;") @goField(forceResolver: true)
    sellingPrice: String!  @goTag(key: "gorm", value: "type:numeric;")
    expiresAt: Time!

    userId: Int!
    user: User! @goTag(key: "gorm", value: "foreignKey:UserID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    productId: Int!
    product: Product! @goTag(key: "gorm", value:  "foreignKey:ProductID;not null;constraint:OnUpdate:RESTRICT,OnDelete:CASCADE;")

    # todo make it nullable when brand is deleted
    brandId: Int
    brand: Brand @goTag(key: "gorm", value:  "foreignKey:BrandID;constraint:OnUpdate:RESTRICT,OnDelete:CASCADE;")
}

input ItemInput {
    quantity: Int!
    buyingPrice: String!
    sellingPrice: String!
    batch: String
    expiresAt: Time

    brandId: Int
    productId: Int!
}

# Even suppliers/customers can be termed as staffs
type Staff implements Gorm {
    id: ID! @goTag(key: "gorm", value: "primaryKey;type:INTEGER")
    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time
    isActive: Boolean!

    userId: Int!
    user: User! @goTag(key: "gorm", value: "foreignKey:UserID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    storeId: Int!
    store: Store! @goTag(key: "gorm", value: "foreignKey:StoreID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")
}

input StaffInput {
    storeId: Int!
    userId: Int!
}


# add tracking type package/tabs
type Store implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")
    deletedAt:Time
    createdAt:Time!
    updatedAt:Time!
    name: String! @goTag(key: "gorm", value: "index;size:50") @goTag(key: "faker",value: "name")
    type: StoreType!

    ownerId: Int!
    owner: User! @goTag(key: "gorm", value: "foreignKey:OwnerID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    staffs: [Staff!]! @goTag(key: "gorm", value: "-")
}

input StoreInput {
    name: String!
}

type Order implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")
    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time
    totalPrice: String! @goTag(key: "gorm", value: "type:numeric;")
    type: OrderType!

    # Customer can be nullable. Since POS don't have to register customer.
    customerId: Int
    customer: User @goTag(key: "gorm", value: "foreignKey:CustomerID;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    staffId: Int!
    staff: User! @goTag(key: "gorm", value: "foreignKey:StaffID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    storeId: Int!
    store: Store! @goTag(key: "gorm", value: "foreignKey:StoreID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    items: [OrderItem!]! @goTag(key: "gorm", value: "-")
}

input OrderInput {
    type: OrderType!
    customerId: Int
    items: [OrderItemInput!]!
}

type OrderItem implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")
    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time
    quantity: Int! @goTag(key: "gorm", value: "type:integer;")
    # user may be given discount. This price of just one item
    sellingPrice: String! @goTag(key: "gorm", value: "type:numeric;")
    # This equals to sellingPrice * quantity
    subTotalPrice: String! @goField(forceResolver: true) @goTag(key: "gorm", value: "-")

    itemId: Int!
    item: Item! @goTag(key: "gorm", value: "foreignKey:ItemID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")
}

input OrderItemInput {
    quantity: Int!
    sellingPrice: String!
    itemId: Int!
}

type Payment implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")
    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time
    amount: String! @goTag(key: "gorm", value: "type:numeric;")
    description: String @goTag(key: "gorm", value: "size:100")
    # Id to identify this payment
    referenceId: String @goTag(key: "gorm", value: "index;size:50")
    type: PaymentType!

    # Payment for what order.
    orderId: Int!
    order: Order! @goTag(key: "gorm", value: "foreignKey:OrderID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")
}

# This just balances items not money
type Ledger implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")
    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time
    quantity: Int! @goTag(key: "gorm", value: "type:integer;")

    # Payment for what order.
    orderId: Int!
    order: Order! @goTag(key: "gorm", value: "foreignKey:OrderID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    # Payment for what order.
    itemId: Int!
    item: Item! @goTag(key: "gorm", value: "foreignKey:ItemID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")
}

type Query {
    brand(id:ID!): Brand!
    brands(productId:ID!): [Brand!]!
    category(id:ID!): Category!
    categories(storeId:ID!): [Category!]!
    item(id: ID!): Item!
    items(storeId:ID!): [Item!]!
    order(id: ID!): Order!
    orders(storeId:ID!): [Order!]!
    payment(id: ID!): Payment!
    payments(storeId:ID!): [Payment!]!
    product(id: ID!): Product!
    products(storeId:ID!): [Product!]!
    staff(id: ID!): Staff!
    staffs(storeId:ID!): [Staff!]!
    store(id: ID!): Store!
    stores: [Store!]!
    user(id: ID!): User!
    users: [User!]!
}

type Mutation {
    createBrand(input: BrandInput!): Brand!
    createCategory(input: CategoryInput!): Category!
    createItem(input: ItemInput!): Item!
    createOrder(input: OrderInput!): Order!
    createProduct(input: ProductInput!): Product!
    createStaff(input: StaffInput!): Staff!
    createStore(input: StoreInput!): Store!
    # Only admins can create new user.
    createUser(input: UserInput!): User!

    changePassword(input: ChangePasswordInput!): User!

    editBrand(id: ID!,input: BrandInput!): Brand!
    editCategory(id: ID!,input: CategoryInput!): Category!
    editItem(id: ID!,input: ItemInput!): Item!
    editOrder(id: ID!,input: OrderInput!): Order!
    editProduct(id: ID!,input: ProductInput!): Product!
    editStaff(id: ID!,input: StaffInput!): Staff!
    editStore(id: ID!,input: StoreInput!): Store!
    editUser(id: ID!,input: UserInput!): User!

    deleteItem(id: ID!): Item!

    # For testing if local ip works. Otherwise client will have to reconfigure.
    ping: String!
}

scalar Time

directive @goModel(
    model: String
    models: [String!]
) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION

directive @goField(
    forceResolver: Boolean
    name: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

directive @goTag(
    key: String!
    value: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION