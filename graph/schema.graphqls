# GraphQL schema example
#
# https://gqlgen.com/getting-started/
interface Gorm {
    id:ID!
    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time
}

enum ItemUnitType {
    tablet
    syrup
    suspension
    package
    box
}

enum OrderType {
    # order for receiving items
    purchase
    # order for selling items
    sale
    # Let's say we pay for some things eg electricity.
    expense
    # If things have expired they can be automatically disposed.
    # todo we should have cron job for doing this.
    expired
    damaged
}

enum PaymentType {
    cash
    loan
    bank
}

enum UserType {
    # can change system settings and assigning employers
    admin
    # who buys
    customer
    # can edit things in store
    staff
    # can assign users in stores
    owner
    # who brings products in
    supplier
}

# Having multiple type will allow transfer between parties
enum StoreType {
    shop
    warehouse
}

# With this user can reuse their credentials in different stores
type User implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")
    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time
    name: String! @goTag(key: "gorm", value: "index;size:50")
    email: String! @goTag(key: "gorm", value: "unique;size:100")
    # null means user has not been configured yet.
    type: UserType @goTag(key: "sql", value: "type:user_type")
}


type Category implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey;type:integer")
    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time
    # tablets/syrups/
    name: String! @goTag(key: "gorm", value: "index;size:50")
    # unit box/each/package
    unit: String @goTag(key: "gorm", value: "size:50;")

    storeId: Int!
    store: Store! @goTag(key: "gorm", value:  "foreignKey:StoreID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")
}

type Item implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")
    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time
    quantity: Int!
    batch: String
    unit: ItemUnitType
    title: String!
    buyingPrice: String!
    sellingPrice: String!
    expiresAt: Time!

    userId: Int!
    user: User! @goTag(key: "gorm", value: "foreignKey:UserID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    categoryId: Int!
    category: Category! @goTag(key: "gorm", value:  "foreignKey:CategoryID;not null;constraint:OnUpdate:RESTRICT,OnDelete:CASCADE;")
}

input ItemInput {
    quantity: Int!
    title: String!
    price: String!
    batch: String
    unit: ItemUnitType
}

# Even suppliers/customers can be termed as staffs
type Staff implements Gorm {
    id: ID! @goTag(key: "gorm", value: "primaryKey;type:INTEGER")
    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time
    isActive: Boolean!

    userId: Int!
    user: User! @goTag(key: "gorm", value: "foreignKey:UserID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    storeId: Int!
    store: Store! @goTag(key: "gorm", value: "foreignKey:StoreID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")
}

input StaffInput {
    storeId: Int!
    userId: Int!
}

input StoreInput {
    title: String!
}

# add tracking type package/tabs
type Store implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")
    deletedAt:Time
    createdAt:Time!
    updatedAt:Time!
    name: String!
    type: StoreType!

    ownerId: Int!
    owner: User! @goTag(key: "gorm", value: "foreignKey:OwnerID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    staffs: [Staff!]! @goTag(key: "gorm", value: "-")
}

type Order implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")
    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time
    totalPrice: String!
    type: OrderType!

    # Customer can be nullable. Since POS don't have to register customer.
    customerId: Int
    customer: User @goTag(key: "gorm", value: "foreignKey:CustomerID;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    staffId: Int!
    staff: User! @goTag(key: "gorm", value: "foreignKey:StaffID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    storeId: Int!
    store: Store! @goTag(key: "gorm", value: "foreignKey:StoreID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")
}

type OrderItem implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")
    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time
    quantity: Int!
    # user may be given discount. This price of just one item
    price: String!

    itemId: Int!
    item: Item! @goTag(key: "gorm", value: "foreignKey:ItemID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")
}

type Payment implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")
    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time
    amount: String! @goTag(key: "gorm", value: "type:numeric;")
    description: String
    # Id to identify this payment
    referenceId: String
    type: PaymentType!

    # Payment for what order.
    orderId: Int!
    order: Order! @goTag(key: "gorm", value: "foreignKey:OrderID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")
}

# This just balances items not money
type Ledger implements Gorm {
    id:ID! @goTag(key: "gorm", value: "primaryKey")
    createdAt:Time!
    updatedAt:Time!
    deletedAt:Time
    quantity: Int! @goTag(key: "gorm", value: "type:integer;")

    # Payment for what order.
    orderId: Int!
    order: Order! @goTag(key: "gorm", value: "foreignKey:OrderID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")

    # Payment for what order.
    itemId: Int!
    item: Item! @goTag(key: "gorm", value: "foreignKey:ItemID;not null;constraint:OnUpdate:RESTRICT,OnDelete:RESTRICT;")
}

type Query {
    category(id:ID!): Category!
    categories(storeId:ID!): [Category!]!
    item(id: ID!): Item!
    items(storeId:ID!): [Item!]!
    store(id: ID!): Store!
    stores: [Store!]!
}

type Mutation {
    createItem(input: ItemInput!): Item!
    createStaff(input: StaffInput!): Staff!
    createStore(input: StoreInput!): Store!
    editItem(id: ID!,input: ItemInput!): Item!
    deleteItem(id: ID!): Item!
}

scalar Time

directive @goModel(
    model: String
    models: [String!]
) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION

directive @goField(
    forceResolver: Boolean
    name: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

directive @goTag(
    key: String!
    value: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION